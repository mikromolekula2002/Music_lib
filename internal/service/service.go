package service

import (
	openapiMusic "mikromolekula2002/music_library_ver1.0/apiAutoGenerated/MusicInfo"
	"mikromolekula2002/music_library_ver1.0/internal/models"
	"mikromolekula2002/music_library_ver1.0/internal/openapi"
	"mikromolekula2002/music_library_ver1.0/internal/repository"
	"net/url"
	"regexp"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

var dateRegex = regexp.MustCompile(`^\d{4}-\d{2}-\d{2}$`)

type MusicLibService struct {
	repo    *repository.Repository
	Logger  *logrus.Logger
	openAPI *openapiMusic.APIClient
}

func NewSongService(repo *repository.Repository, logger *logrus.Logger, musicAPIHost, musicBaseURL string) *MusicLibService {
	return &MusicLibService{
		repo:    repo,
		Logger:  logger,
		openAPI: openapi.MakeMusicAPIClient(musicAPIHost, musicBaseURL),
	}
}

func (s *MusicLibService) SaveSong(song *models.Song) error {

	songID, err := s.repo.SaveSongInfo(song.Group, song.Song, song.ReleaseDate, song.Link)
	if err != nil {
		s.Logger.Error(err)
		return err
	}

	s.Logger.Debug("Song info saved successfully", logrus.Fields{"songID": songID})

	song.ID = uint(songID)

	verses := strings.Split(song.Text, "\n\n")
	for _, val := range verses {
		if err := s.repo.SaveSongText(song.ID, val); err != nil {
			s.Logger.Error(err)
			return err
		}
	}

	s.Logger.Debug("Song text saved successfully", logrus.Fields{"songID": songID})

	return nil
}

func (s *MusicLibService) GetSongDetailsFromAPI(group string, song string, ctx *gin.Context) (*models.Song, error) {
	op := "service.GetSongDetailsFromAPI"

	s.Logger.Debug("Fetching song text", logrus.Fields{
		"group": group,
		"song":  song,
	})

	params := url.Values{}
	params.Add("group", group)
	params.Add("song", song)

	resp, _, err := s.openAPI.DefaultAPI.InfoGet(ctx).Group(group).Song(song).Execute()
	if err != nil {
		s.Logger.Errorf("%s: %v", op, err)
		return nil, err
	}

	songData := &models.Song{
		Group:       group,
		Song:        song,
		Text:        resp.Text,
		Link:        resp.Link,
		ReleaseDate: resp.ReleaseDate,
	}

	return songData, nil
}

func (s *MusicLibService) GetSongTextByGroup(groupName, songName string, songLimit, songOffset int) ([]string, error) {
	s.Logger.Debug("Fetching song text", logrus.Fields{"group": groupName, "song": songName, "limit": songLimit, "offset": songOffset})

	songsParts, err := s.repo.GetSongTextByGroup(groupName, songName, songLimit, songOffset)
	if err != nil {
		s.Logger.Error(err)
		return nil, err
	}

	return songsParts, nil
}

func (s *MusicLibService) UpdateSong(song *models.Song) error {
	s.Logger.Debug("Updating song", logrus.Fields{"group": song.Group, "song": song.Song})

	verses := []string{}
	if song.Text != "" {
		verses = strings.Split(song.Text, "\n\n")
	}

	if err := s.repo.UpdateSong(song.Group, song.Song, song.ReleaseDate, song.Link, verses); err != nil {
		s.Logger.Error(err)
		return err
	}

	s.Logger.Debug("Song updated", logrus.Fields{"group": song.Group, "song": song.Song})

	return nil
}

func (s *MusicLibService) DeleteSong(groupName, songName string) error {
	if err := s.repo.DeleteSong(groupName, songName); err != nil {
		s.Logger.Error(err)
		return err
	}

	s.Logger.Debug("Song deleted", logrus.Fields{"group": groupName, "song": songName})

	return nil
}

func (s *MusicLibService) GetAllSongs(filter map[string]string, limit, offset int) ([]models.Song, error) {
	s.Logger.Debug("Fetching all songs", logrus.Fields{"limit": limit, "offset": offset, "filters": filter})

	songs, err := s.repo.GetSongs(filter, limit, offset)
	if err != nil {
		s.Logger.Error(err)
		return nil, err
	}

	s.Logger.Debug("Fetched songs count", logrus.Fields{"count": len(songs)}) // Непонятный лог, он не кол-во песен логирует, а соджержимое одной песни

	return songs, nil
}

func (s *MusicLibService) IsValidDate(date string) bool {
	return dateRegex.MatchString(date)
}
